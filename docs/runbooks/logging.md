# Logging in MaLPA

This is an overview of how we log the progress of a request through the MaLPA stack.

It also covers the philosophy we apply when deciding what to log, and details of how to use our logging classes.

For an overview of how data moves through the stack, see [data flows](./data_flows.md).

## Trace ID logging

We use the incoming `X-Amzn-Trace-Id` header as the key which ties together log entries, as explained below. This header is added to incoming requests coming through the AWS load balancers which sit in front of the *-web containers.

Using the value of this header as a key enables us to trace requests from the load balancers all the way through to back-end services and out again.

**Note that these examples show a mocked-out Amazon trace header, as provided by the *-ssl containers (see next section).**

### Ordering log entries for the public application

For requests to the public application, the log entries arise from the containers in this sequence:

```
1.  front-ssl (local dev) / AWS load balancer
2.  front-web (nginx access log)
3.  front-app (php-fpm access log)
4.  front-app (application log)
5a. api-web (nginx access log)
    1. api-app (php-fpm access log)
    2. api-app (application log)
        1a. RDS
        1b. Sirius
        1c. SQS
5b. dynamodb
5c. pdf-app (application log)
    1. SQS
```

Further explanation:

* front-app talks to api-web, dynamodb and pdf-app. Requests from front-app may therefore trigger log events in one or more of those systems.
* api-app talks to RDS, Sirius and SQS. A call to an endpoint on the API may therefore trigger log events in one or more of those systems.
* pdf-app uses SQS, so jobs generated by front-app or api-app may trigger log events in that system.

If writing a log processor, the timings on the log entries may not provide enough granularity to work out the order of log events. The above sequence should help resolve any ordering ambiguities to reveal the sequence of calls between systems.

### front-ssl/admin-ssl

These containers only exist in dev. They mock the load balancers which pass traffic on to the front-web/admin-web components in live.

Each is an nginx proxy (based on docker-ssl-proxy) modified to proxy requests with additional mock `X-Amzn-Trace-Id` header to the *-web containers.

### front-web/admin-web/api-web

nginx proxies which receive traffic from front-ssl/admin-ssl respectively and forward it to the front-end application (front-app/admin-app). Incoming requests are logged in an access log.

Log entries look like this:

```
{
   "trace_id":"Root=1-1608303221.805-152-fromssl",
   "time_local":"18/Dec/2020:14:53:41 +0000",
   "response_time_iso8601":"2020-12-18T14:53:41+00:00",
   "timestamp_msec":"1608303221.895",
   "remote_addr":"192.168.80.9",
   "real_ip":"192.168.80.1",
   "real_forwarded_for":"192.168.80.1",
   "real_forwarded_proto":"https",
   "request_id":"",
   "remote_user":"",
   "request_time":0.090,
   "request_uri":"/home",
   "status":200,
   "request":"GET /home HTTP/1.0",
   "request_method":"GET",
   "http_referrer":"",
   "http_user_agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36",
   "bytes_sent":13044,
   "http_host":"localhost",
   "sent_http_location":"",
   "server_name":"_",
   "server_port":"80",
   "upstream_addr":"192.168.80.17:9000",
   "upstream_response_length":"12656",
   "upstream_response_time":"0.092",
   "upstream_status":"200"
}
```

This format is modelled after the JSON nginx log format used by Sirius. Both static assets and PHP resources are logged using the same format. However, as requests for static assets are separate from the original request for the page, they will carry different trace IDs.

The `X-Amzn-Trace-Id` header is forwarded with requests proxied to front-app/admin-app but renamed as `X-Trace-Id`.

### front-app/admin-app/api-app

PHP apps running under php-fpm on separate containers. There are two types of logs gathered by each container.

#### 1. php-fpm access log

The access log goes to stdout/stderr in JSON format. The format is close to the one used in the *-web containers and logs incoming requests for PHP resources. It includes a `trace_id` property which can be tied back to the original incoming request.

Example:

```
{
   "trace_id":"Root=1-1609928880.226-22-fromssl",
   "time_iso8601":"2021-01-06T10:28:00+0000",
   "time_local":"06/Jan/2021:10:28:00 +0000",
   "remote_addr":"172.29.0.17",
   "real_ip":"172.29.0.1",
   "real_forwarded_for":"172.29.0.1",
   "real_forwarded_proto":"https",
   "request_time":"0.117",
   "request_uri":"http://localhost:7002/home",
   "status":"200",
   "request_method":"GET",
   "http_referrer":"-",
   "http_user_agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36",
   "bytes_sent":"0",
   "http_host":"localhost:7002",
   "server_name":"_",
   "server_port":"80"
}
```

This access log format is configured via the [log configuration for php-fpm](https://www.php.net/manual/en/install.fpm.configuration.php) in the `php-fpm-logging.conf` config files. Separate files are used, one for each *-app container (though they are all identical). These files are copied into the corresponding `docker/app` images during docker builds.

#### 2. Application log

These also output to stdout/stderr but are in a slightly expanded format, containing less information about IP addresses but more information about the request, such as its headers. Each entry also contains a reference to the `trace_id` of the original request which generated the error.

When a PHP error occurs, log entries also contain additional logging about the file which caused the error, the exception stacktrace and other useful data.

Other informational/debug application logging is output in a similar format. The `$extra` argument which can be passed to Laminas' logger methods can be used to provide extra context. See the section on PHP logging below for more details.

Example log output for an exception thrown by a controller:

```
{
   "timestamp":"2020-12-18T14:56:55+00:00",
   "priority":3,
   "priorityName":"ERR",
   "message":"dispatch.error",
   "trace_id":"Root=1-1608303415.248-371-fromssl",
   "request":{
      "uri":"https://localhost:7002/home",
      "method":"GET",
      "headers":{
         "Accept-Language":"en-GB, en-US;q=0.9, en;q=0.8",
         "Accept-Encoding":"gzip, deflate, br",
         "Sec-Fetch-Dest":"document",
         "Sec-Fetch-User":"?1",
         "Sec-Fetch-Mode":"navigate",
         "Sec-Fetch-Site":"none",
         "Accept":"text/html, application/xhtml+xml, application/xml;q=0.9, image/avif, image/webp, image/apng, */*;q=0.8, application/signed-exchange;v=b3;q=0.9",
         "User-Agent":"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36",
         "Upgrade-Insecure-Requests":1,
         "Cache-Control":"max-age=0",
         "X-Amzn-Trace-Id":"Root=1-1608303415.248-371-fromssl",
         "Connection":"close",
         "X-Forwarded-Host":"localhost",
         "X-Forwarded-Proto":"https",
         "X-Forwarded-For":"192.168.80.1",
         "X-Real-Ip":"192.168.80.1",
         "Host":"localhost:7002",
         "X-Trace-Id":"Root=1-1608303415.248-371-fromssl"
      }
   },
   "controller":"General\\HomeController",
   "exception":{
      "message":"EXCEPTION FORCED FOR DEMO PURPOSES",
      "file":"/app/module/Application/src/Controller/General/HomeController.php",
      "line":15,
      "stackTrace":"#0 /app/vendor/laminas/laminas-mvc/src/Controller/AbstractActionController.php(77): Application\\Controller\\General\\HomeController->indexAction()\n#1 /app/vendor/laminas/laminas-eventmanager/src/EventManager.php(331): Laminas\\Mvc\\Controller\\AbstractActionController->onDispatch(Object(Laminas\\Mvc\\MvcEvent))\n#2 /app/vendor/laminas/laminas-eventmanager/src/EventManager.php(188): Laminas\\EventManager\\EventManager->triggerListeners(Object(Laminas\\Mvc\\MvcEvent), Object(Closure))\n#3 /app/vendor/laminas/laminas-mvc/src/Controller/AbstractController.php(103): Laminas\\EventManager\\EventManager->triggerEventUntil(Object(Closure), Object(Laminas\\Mvc\\MvcEvent))\n#4 /app/vendor/laminas/laminas-mvc/src/DispatchListener.php(139): Laminas\\Mvc\\Controller\\AbstractController->dispatch(Object(Laminas\\Http\\PhpEnvironment\\Request), Object(Laminas\\Http\\PhpEnvironment\\Response))\n#5 /app/vendor/laminas/laminas-eventmanager/src/EventManager.php(331): Laminas\\Mvc\\DispatchListener->onDispatch(Object(Laminas\\Mvc\\MvcEvent))\n#6 /app/vendor/laminas/laminas-eventmanager/src/EventManager.php(188): Laminas\\EventManager\\EventManager->triggerListeners(Object(Laminas\\Mvc\\MvcEvent), Object(Closure))\n#7 /app/vendor/laminas/laminas-mvc/src/Application.php(331): Laminas\\EventManager\\EventManager->triggerEventUntil(Object(Closure), Object(Laminas\\Mvc\\MvcEvent))\n#8 /app/public/index.php(31): Laminas\\Mvc\\Application->run()\n#9 {main}"
   },
   "errorMessage":"error-exception"
}
```

## PHP application logging

Logging in service-front and service-api makes use of a `LoggerTrait` class to provide logging functionality.

Originally, the opg-lpa-logger module was being pulled in to provide the `LoggerTrait`. However, this provided no flexibility to change the log output format or attach extra processors. Instead, we use our own class which is configured to output logs in JSON.

While it would be nice to inject the logger into classes via Laminas' dependency injection mechanism, this would require wide-ranging changes to all three of the *-app code bases. We decided to stick with the trait approach as a consequence.

Several key parts of the code use our custom `LoggerTrait`:

* front-app
  * Most controllers via `AbstractBaseController`
  * Other controllers which don't inherit from `AbstractBaseController`
  * Most services via `AbstractService`
  * Other services, such as the `APIClient`, where they don't inherit from `AbstractService`
  * An [MVC event listener](https://docs.laminas.dev/laminas-mvc/mvc-event/) which captures and logs application-level errors. The listener was originally baked into the bootstrap function for the app, but was moved into a cleaner, separate class to make it simpler to test.
* api-app
  * Most controllers via `AbstractAuthController`
  * Other controllers, such as the `PingController`, which don't inherit from `AbstractAuthController`
  * All services via `AbstractService`
  * An MVC event listener, as per service-front

(You can figure out where the logger is injected by looking for a `use LoggerTrait;` statement in a class.)

Our logger also has attached processors which modify the log output in a couple of ways:

* `TraceIdProcessor`: looks for a trace ID header on the incoming request and adds it to the log output
* `HeadersProcessor`: strips any sensitive headers out of the request before it is logged
* `MvcEventProcessor`: this is tailored to recognise and reformat MVC events into an easier-to-read format before they are written to the log

## Increasing api logging
Sometimes there is a need to examine what the front end has sent to the back-end api. 
To achieve this, modify nginx.conf to add (in the server directive)

```
client_body_in_file_only on
```

Then in the log_format section, add 

```
'"request_body_file": "$request_body_file"'  
```

not forgetting to append a comma on the previous line.

Rebuild the lpa-api-web container

Then while running, e:g during a cypress scenario, write logs to a file:

```
docker logs -ft lpa-api-web | tee apiweblog
```

Then extract from this - ignore authenticate or session-expiry calls which happen a lot,  cut the timestamp off the front, leaving json which we can jq to get the request and the body file name, then use xargs to try to get the file content from the container , where this text relates to an existing file 

```
 cat apiweblog | grep -v "authenticate\|session-expiry" | cut -c 32- | jq .request,.request_body_file | xargs -I % sh -c 'printf "\n%" ; docker exec lpa-api-web cat % ' 2>/dev/null
```
