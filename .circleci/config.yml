version: 2.1

pr_build: &pr_build
  jobs:
    - cancel_redundant_builds:
        name: cancel_previous_jobs
        filters: { branches: { ignore: [master] } }

    - build_containers_and_push_to_ecr/node_build_web:
        name: node_build_web
        filters: { branches: { ignore: [ master ] } }

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: front_docker_build
        ecr_repository_name_prefix: online-lpa/front
        service_path: service-front
        filters: { branches: { ignore: [master] } }
        requires: [node_build_web]

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: admin_docker_build
        ecr_repository_name_prefix: online-lpa/admin
        service_path: service-admin
        filters: { branches: { ignore: [master] } }

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: api_docker_build
        ecr_repository_name_prefix: online-lpa/api
        service_path: service-api
        filters: { branches: { ignore: [master] } }

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: pdf_docker_build
        ecr_repository_name_prefix: online-lpa/pdf
        service_path: service-pdf
        build_web: false
        filters: { branches: { ignore: [master] } }

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: seeding_docker_build
        ecr_repository_name_prefix: online-lpa/seeding
        service_path: service-seeding
        build_web: false
        unit_test: false
        filters: { branches: { ignore: [master] } }

    - infrastructure_and_deployment/lint_account_terraform:
        name: lint_account_terraform_pr_build
        filters: { branches: { ignore: [master] } }

    - infrastructure_and_deployment/lint_environment_terraform:
        name: lint_environment_terraform_pr_build
        filters: { branches: { ignore: [master] } }

    - infrastructure_and_deployment/plan_check_terraform:
        name: dev_account_plan_check_terraform_pr_build
        workspace: development
        terraform_level: account
        approval_step: "dev_infra_approval_terraform_apply_account_pr_build"
        filters: { branches: { ignore: [master] } }
        requires: [cancel_previous_jobs, lint_account_terraform_pr_build]

    - hold_for_approval_tf:
        name: dev_infra_approval_terraform_apply_account_pr_build
        type: approval
        filters: { branches: { ignore: [master] } }
        requires: [lint_account_terraform_pr_build]

    - infrastructure_and_deployment/plan_check_terraform:
        name: dev_environment_plan_check_terraform_pr_build
        terraform_level: environment
        approval_step: "dev_infra_approval_terraform_apply_environment_pr_build"
        filters: { branches: { ignore: [master] } }
        requires: [cancel_previous_jobs, lint_environment_terraform_pr_build]

    - hold_for_approval_tf:
        name: dev_infra_approval_terraform_apply_environment_pr_build
        type: approval
        filters: { branches: { ignore: [master] } }
        requires: [lint_environment_terraform_pr_build]

    - infrastructure_and_deployment/apply_account_terraform:
        name: dev_account_apply_terraform
        workspace: development
        filters: { branches: { ignore: [master] } }
        requires:
          [
            cancel_previous_jobs,
            dev_infra_approval_terraform_apply_account_pr_build,
          ]

    - infrastructure_and_deployment/apply_email_terraform:
        name: email_apply_terraform
        workspace: development
        filters: { branches: { ignore: [master] } }
        requires: [cancel_previous_jobs, lint_account_terraform_pr_build]

    - infrastructure_and_deployment/apply_environment_terraform:
        name: dev_environment_apply_terraform
        filters: { branches: { ignore: [master] } }
        requires:
          [
            cancel_previous_jobs,
            lint_environment_terraform_pr_build,
            dev_infra_approval_terraform_apply_environment_pr_build,
            dev_account_apply_terraform,
            front_docker_build,
            admin_docker_build,
            api_docker_build,
            pdf_docker_build,
            seeding_docker_build,
          ]

    - ecr_scan_results:
        name: ecr_scan_results_development
        filters: { branches: { ignore: [master] } }
        requires:
          [
            front_docker_build,
            admin_docker_build,
            api_docker_build,
            pdf_docker_build,
            seeding_docker_build,
          ]

    - infrastructure_and_deployment/seed_environment_databases:
        name: dev_seed_environment_databases
        filters: { branches: { ignore: [master] } }
        requires: [dev_environment_apply_terraform]

    - infrastructure_and_deployment/run_cypress_test:
        name: run_cypress_test_stitchedpf
        cypress_tags: "@StitchedPF"
        filters: { branches: { ignore: [master] } }
        requires: [dev_seed_environment_databases]

    - infrastructure_and_deployment/run_cypress_test:
        name: run_cypress_test_stitchedpfclone
        cypress_tags: "@StitchedClone"
        filters: { branches: { ignore: [master] } }
        requires: [dev_seed_environment_databases]

    - infrastructure_and_deployment/run_cypress_test:
        name: run_cypress_test_stitchedhw
        cypress_tags: "@StitchedHW"
        filters: { branches: { ignore: [master] } }
        requires: [dev_seed_environment_databases]

    - infrastructure_and_deployment/run_cypress_test:
        name: run_cypress_test_remaining_tests
        cypress_tags: "not @SignUp and not @CreateLpa and not @StitchedHW and not @StitchedPF and not @StitchedClone and not @Statuses and not @Reusable"
        filters: { branches: { ignore: [master] } }
        requires: [dev_seed_environment_databases]

    - infrastructure_and_deployment/run_functional_test:
        name: run_functional_test
        filters: { branches: { ignore: [master] } }
        requires: [dev_seed_environment_databases]

    - slack_notify_domain:
        name: post_environment_domains
        filters: { branches: { ignore: [master] } }
        requires:
          [
            dev_seed_environment_databases
          ]

path_to_live: &path_to_live
  jobs:
    - build_containers_and_push_to_ecr/node_build_web:
        name: node_build_web
        filters: { branches: { only: [ master ] } }

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: front_docker_build
        ecr_repository_name_prefix: online-lpa/front
        service_path: service-front
        filters: { branches: { only: [master] } }
        requires: [node_build_web]

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: admin_docker_build
        ecr_repository_name_prefix: online-lpa/admin
        service_path: service-admin
        filters: { branches: { only: [master] } }

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: api_docker_build
        ecr_repository_name_prefix: online-lpa/api
        service_path: service-api
        filters: { branches: { only: [master] } }

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: pdf_docker_build
        ecr_repository_name_prefix: online-lpa/pdf
        service_path: service-pdf
        build_web: false
        filters: { branches: { only: [master] } }

    - build_containers_and_push_to_ecr/checkout_docker_build_push_web-app:
        name: seeding_docker_build
        ecr_repository_name_prefix: online-lpa/seeding
        service_path: service-seeding
        build_web: false
        unit_test: false
        filters: { branches: { only: [master] } }

    - infrastructure_and_deployment/plan_check_terraform:
        name: preprod_account_plan_check_terraform_pr_build
        workspace: preproduction
        terraform_level: account
        approval_step: "preprod_infra_approval_terraform_apply_account_pr_build"
        filters: { branches: { only: [master] } }

    - infrastructure_and_deployment/plan_check_terraform:
        name: preprod_environment_plan_check_terraform_pr_build
        workspace: preproduction
        terraform_level: environment
        approval_step: "preprod_infra_approval_terraform_apply_environment_pr_build"
        filters: { branches: { only: [master] } }

    - hold_for_approval_tf:
        name: preprod_infra_approval_terraform_apply_account_pr_build
        type: approval
        filters: { branches: { only: [master] } }

    - hold_for_approval_tf:
        name: preprod_infra_approval_terraform_apply_environment_pr_build
        type: approval
        filters: { branches: { only: [master] } }

    - infrastructure_and_deployment/apply_account_terraform:
        name: preprod_account_apply_terraform
        workspace: preproduction
        filters: { branches: { only: [master] } }
        requires:
          [
            preprod_infra_approval_terraform_apply_account_pr_build,
          ]

    - infrastructure_and_deployment/apply_environment_terraform:
        name: preprod_environment_apply_terraform
        workspace: preproduction
        filters: { branches: { only: [master] } }
        requires:
          [
            preprod_account_apply_terraform,
            preprod_infra_approval_terraform_apply_environment_pr_build,
            front_docker_build,
            admin_docker_build,
            api_docker_build,
            pdf_docker_build,
            seeding_docker_build,
          ]

    - ecr_scan_results:
        name: ecr_scan_results_master
        filters: { branches: { only: [master] } }
        requires:
          [
            front_docker_build,
            admin_docker_build,
            api_docker_build,
            pdf_docker_build,
          ]

    - infrastructure_and_deployment/seed_environment_databases:
        name: preprod_seed_environment_databases
        workspace: preproduction
        filters: { branches: { only: [master] } }
        requires: [preprod_environment_apply_terraform]

    - infrastructure_and_deployment/run_cypress_test:
        name: preprod_test_cypress_stitchedpf
        cypress_tags: "@StitchedPF"
        workspace: preproduction
        filters: { branches: { only: [master] } }
        requires: [preprod_seed_environment_databases]

    - infrastructure_and_deployment/run_cypress_test:
        name: preprod_test_cypress_stitchedhw
        cypress_tags: "@StitchedHW"
        workspace: preproduction
        filters: { branches: { only: [master] } }
        requires: [preprod_seed_environment_databases]

    - infrastructure_and_deployment/run_cypress_test:
        name: preprod_test_cypress_remaining_tests
        cypress_tags: "not @SignUp and not @CreateLpa and not @StitchedHW and not @StitchedPF and not @StitchedClone and not @Statuses and not @Reusable"
        workspace: preproduction
        filters: { branches: { only: [master] } }
        requires: [preprod_seed_environment_databases]

    - infrastructure_and_deployment/run_functional_test:
        name: preprod_test_functional
        workspace: preproduction
        filters: { branches: { only: [master] } }
        requires: [preprod_seed_environment_databases]

    - infrastructure_and_deployment/apply_account_terraform:
        name: prod_account_apply_terraform
        workspace: production
        filters: { branches: { only: [master] } }
        requires:
          [
            preprod_test_functional,
            preprod_test_cypress_stitchedpf,
            preprod_test_cypress_stitchedhw,
            preprod_test_cypress_remaining_tests,
          ]

    - infrastructure_and_deployment/apply_environment_terraform:
        name: prod_environment_apply_terraform
        requires: [prod_account_apply_terraform]
        filters: { branches: { only: [master] } }
        workspace: production

    - infrastructure_and_deployment/run_healthcheck_test:
        name: test_healthcheck_prod
        requires: [prod_environment_apply_terraform]
        filters: { branches: { only: [master] } }
        workspace: production

    - slack_notify_production_release:
        name: post_production_release_message
        filters: { branches: { only: [master] } }
        requires: [test_healthcheck_prod]

workflows:
  workspace_cleanup:
    triggers:
      - schedule:
          cron: "0 6,18 * * 0-6" # 6am and 6pm
          filters:
            branches:
              only:
                - master
    jobs:
      - workspace_cleanup:
          name: workspace_cleanup

  pr_build:
    <<: *pr_build

  path_to_live:
    <<: *path_to_live

  weekly_refresh:
    triggers:
      - schedule:
          cron: "0 3 * * 3" # 3 am (UTC) on wednesday
          filters:
            branches:
              only:
                - master
    <<: *path_to_live

orbs:
  my_slack: &slack_orb
    executors:
      python:
        docker:
        - image: circleci/python
          auth:
            username: $DOCKER_USER
            password: $DOCKER_ACCESS_TOKEN
        resource_class: small
    commands:
      notify:
        parameters:
          slack_channel:
            type: string
            description: Slack channel id to use
          template_file:
            type: string
            description: template filename to use
          template_folder:
            type: string
            default: "templates"
            description: provide a path for your template files. Default is templates (folder relative to slack script)
          replacement_vars:
            type: string
            description: additional values to provide on top of environment variables. Provide key value pairs eg "stage=testing"
            default: ""
          when:
            type: enum
            default: always
            enum:
              - on_fail
              - on_success
              - always
        steps:
          - run:
              command: |
                echo 'export STEP_STATUS="on_fail"' >> /tmp/SLACK_JOB_STATUS
              name: Slack - Detecting Job Status - on fail
              when: on_fail
          - run:
              command: |
                echo 'export STEP_STATUS="on_success"' >> /tmp/SLACK_JOB_STATUS

              name: Slack - Detecting Job Status - on success
              when: on_success
          - run:
              when: always
              command: |
                echo 'export SLACK_PARAM_WHEN="<<parameters.when>>"' >> /tmp/SLACK_JOB_STATUS

              name: store when to run notification
          - run:
              when: always
              name: notify_channel
              command: |
                . "/tmp/SLACK_JOB_STATUS"

                if [ "$STEP_STATUS" = "$SLACK_PARAM_WHEN" ] || [ "$SLACK_PARAM_WHEN" = "always" ]; then

                  echo "Posting message..."

                  cd ~/project/scripts/pipeline/slack_notifications
                  pip install -r requirements.txt
                  chmod +x ./notify_slack_from_template.py
                  python3 ./notify_slack_from_template.py --template_file=<<parameters.template_file>>  \
                                                      --slack_channel=<<parameters.slack_channel>> \
                                                      --slack_token=$SLACK_ACCESS_TOKEN\
                                                      --vars <<parameters.replacement_vars>>
                else
                  echo "Skipping message send."
                  echo
                  echo "This command is set to send an alert when status is: $SLACK_PARAM_WHEN"
                  echo "Current status is: ${STEP_STATUS}"
                fi

  build_containers_and_push_to_ecr:
    orbs:
      docker: circleci/docker@1.4.0
    commands:
      dockerhub_login:
        steps:
          - docker/install-docker-credential-helper
          - docker/check:
              docker-password: DOCKER_ACCESS_TOKEN
              docker-username: DOCKER_USER
      install_aws_cli:
        steps:
          - run:
              name: Install AWS CLI
              command: sudo pip3 install awscli --upgrade
      ecr_login:
        steps:
          - run:
              name: Login to ECR
              command: |
                temp_role=$(aws sts assume-role --role-arn arn:aws:iam::311462405659:role/opg-lpa-ci --role-session-name opg-lpa-ci)
                export AWS_ACCESS_KEY_ID=$(echo $temp_role | jq .Credentials.AccessKeyId | xargs)
                export AWS_SECRET_ACCESS_KEY=$(echo $temp_role | jq .Credentials.SecretAccessKey | xargs)
                export AWS_SESSION_TOKEN=$(echo $temp_role | jq .Credentials.SessionToken | xargs)
                aws ecr get-login-password --region eu-west-1 | docker login --username AWS --password-stdin 311462405659.dkr.ecr.eu-west-1.amazonaws.com
    executors:
      python:
        docker:
          - image: circleci/python
            auth:
              username: $DOCKER_USER
              password: $DOCKER_ACCESS_TOKEN
        resource_class: small
      ruby-node:
        docker:
          - image: circleci/ruby:3.0.1-node
            auth:
              username: $DOCKER_USER
              password: $DOCKER_ACCESS_TOKEN
        resource_class: small

    jobs:
      checkout_docker_build_push_web-app:
        executor: python
        parameters:
          ecr_url:
            type: string
            default: 311462405659.dkr.ecr.eu-west-1.amazonaws.com
          ecr_repository_name_prefix:
            type: string
            description: The ecr repo name up to _app or _web. These will be assumed to be present and added by the job.
          service_path:
            type: string
          build_web:
            type: boolean
            default: true
            description: Some services do not require a web container, set to False to skip web container builds.
          unit_test:
            type: boolean
            default: true
            description: Execute unit tests during this build

        steps:
          - checkout
          - install_aws_cli
          - setup_remote_docker:
              version: 19.03.12
              docker_layer_caching: false
          - attach_workspace:
              at: ~/project
          - dockerhub_login
          - run:
              name: Build web container
              command: |
                if << parameters.build_web >> ; then
                  docker build -f << parameters.service_path >>/docker/web/Dockerfile --progress=plain --no-cache -t << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_web .
                else
                  echo "web container not required for this service"
                fi
          - run:
              name: Build app container
              command: |
                docker build -f << parameters.service_path >>/docker/app/Dockerfile --progress=plain --no-cache -t << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_app .
          - run:
              name: Run unit tests
              command: |
                if << parameters.unit_test >> ; then
                  docker run -d --env AWS_ACCESS_KEY_ID='-' --env AWS_SECRET_ACCESS_KEY='-' --name tests << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_app:latest
                  docker exec tests docker-php-ext-enable xdebug
                  docker exec tests /app/vendor/bin/phpunit -d memory_limit=256M
                else
                  echo "phpunit tests not required for this service"
                fi
          - ecr_login
          - run:
              name: Push web container
              command: |
                export IMAGE_TAG=$(bash ~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
                echo $IMAGE_TAG
                if << parameters.build_web >> ; then
                  docker tag << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_web << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_web:${IMAGE_TAG}
                  if [ "${CIRCLE_BRANCH}" == "master" ]; then
                    # If master, push branch tag and latest
                    docker tag << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_web:${IMAGE_TAG} << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_web:latest
                    docker push << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_web
                  else
                    # Else, push branch tag only
                    docker push << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_web:${IMAGE_TAG}
                  fi
                fi
          - run:
              name: Push app container
              command: |
                export IMAGE_TAG=$(bash ~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
                echo $IMAGE_TAG
                docker tag << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_app << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_app:${IMAGE_TAG}
                if [ "${CIRCLE_BRANCH}" == "master" ]; then
                  # If master, push branch tag and latest
                  docker tag << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_app:${IMAGE_TAG} << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_app:latest
                  docker push << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_app
                else
                  # Else, push branch tag only
                  docker push << parameters.ecr_url >>/<< parameters.ecr_repository_name_prefix >>_app:${IMAGE_TAG}
                fi

      node_build_web:
        #
        # Build frontend assets (css, js)
        #
        executor: ruby-node
        steps:
          - checkout
          - restore_cache:
              name: Restore node modules cache
              key: node_modules-{{ checksum "service-front/package-lock.json" }}
          - run:
              name: Install dependencies
              command: |
                if [ ! -d service-front/node_modules ]; then
                  cd service-front/ && npm install
                fi
                # installing via npm does not pull down correct files to call via cli, resorted to pulling directly
                export SASS_VER=`npm view sass | grep latest | awk '{print $2}'`
                wget "https://github.com/sass/dart-sass/releases/download/$SASS_VER/dart-sass-$SASS_VER-linux-x64.tar.gz"
                tar xfz "dart-sass-$SASS_VER-linux-x64.tar.gz"
          - run:
              name: Build assets
              command: |
                export REVISION=$(bash ~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1)
                echo "Using REVISION ${REVISION} for cache busting"
                export PATH="/home/circleci/project/service-front/dart-sass:$PATH"
                cd service-front/ && node_modules/grunt-cli/bin/grunt build
          - save_cache:
              name: Save node modules cache
              key: node_modules-{{ checksum "service-front/package-lock.json" }}
              paths:
                - service-front/node_modules
          - persist_to_workspace:
              root: /home/circleci/project
              paths:
                - service-front/public/assets
              when: always

  infrastructure_and_deployment:
    orbs:
      my_slack:
        <<: *slack_orb
      docker: circleci/docker@1.4.0
    commands:
      dockerhub_login:
        steps:
          - docker/install-docker-credential-helper
          - docker/check:
              docker-password: DOCKER_ACCESS_TOKEN
              docker-username: DOCKER_USER
      install_workspace_manager:
        steps:
          - run:
              name: Install Terraform Workspace Manager
              command: |
                pwd
                apk add libc6-compat
                wget https://github.com/TomTucka/terraform-workspace-manager/releases/download/v0.3.1/terraform-workspace-manager_Linux_x86_64.tar.gz
                tar -xzf terraform-workspace-manager_Linux_x86_64.tar.gz
                chmod +x terraform-workspace-manager

      install_aws_cli:
        steps:
          - run:
              name: Install AWS CLI
              command: sudo pip3 install awscli --upgrade
      install_terraform:
        steps:
          - run:
              name: Install Terraform
              command: |
                export TERRAFORM_VERSION=1.0.0
                export TERRAFORM_SHA256SUM=8be33cc3be8089019d95eb8f546f35d41926e7c1e5deff15792e969dde573eb5
                curl https://releases.hashicorp.com/terraform/${TERRAFORM_VERSION}/terraform_${TERRAFORM_VERSION}_linux_amd64.zip > terraform_${TERRAFORM_VERSION}_linux_amd64.zip
                echo "${TERRAFORM_SHA256SUM}  terraform_${TERRAFORM_VERSION}_linux_amd64.zip" > terraform_${TERRAFORM_VERSION}_SHA256SUMS
                sha256sum -c --status terraform_${TERRAFORM_VERSION}_SHA256SUMS
                sudo unzip terraform_${TERRAFORM_VERSION}_linux_amd64.zip -d /bin
                rm -f terraform_${TERRAFORM_VERSION}_linux_amd64.zip
    executors:
      python:
        docker:
          - image: circleci/python
            auth:
              username: $DOCKER_USER
              password: $DOCKER_ACCESS_TOKEN
        resource_class: small
      python-build:
        docker:
          - image: python:alpine
            auth:
              username: $DOCKER_USER
              password: $DOCKER_ACCESS_TOKEN
        resource_class: small
      python-browsers:
        docker:
          - image: circleci/python:3.6-stretch-browsers
            auth:
              username: $DOCKER_USER
              password: $DOCKER_ACCESS_TOKEN
        resource_class: small
      terraform:
        docker:
          - image: hashicorp/terraform:1.0.0
            auth:
              username: $DOCKER_USER
              password: $DOCKER_ACCESS_TOKEN
        resource_class: small
    jobs:
      #----------------------------------------------------
      # Terraform
      lint_account_terraform:
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
        executor: terraform
        steps:
          - checkout
          - run:
              name: terraform lint
              command: terraform fmt -diff -check -recursive
          - run:
              name: Validate Account Terraform
              command: |
                terraform --version
                cd ~/project/terraform/account
                terraform init
                export TF_WORKSPACE=development >> $BASH_ENV
                echo $TF_WORKSPACE
                terraform validate
      lint_environment_terraform:
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
        executor: terraform
        steps:
          - checkout
          - run:
              name: Lint Environment Terraform
              command: |
                export IMAGE_TAG=$(~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
                echo $IMAGE_TAG
                cd ~/project/terraform/environment
                terraform init
                export TF_WORKSPACE=$(~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                terraform validate

      apply_email_terraform:
        #
        # Apply the email terraform configuration. This:
        #   - Creates a mailbox used for functional testing;
        #
        executor: terraform
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: development
        steps:
          - checkout
          - run:
              name: Apply Email Terraform
              command: |
                cd ~/project/terraform/email
                terraform init
                export TF_WORKSPACE=$(~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                terraform apply -lock-timeout=300s --auto-approve

      apply_account_terraform:
        #
        # Apply the shared terraform configuration. This:
        #   - Updates the account infrastructure;
        #
        executor: terraform
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: development
        steps:
          - checkout
          - run:
              name: Apply Account Terraform
              command: |
                cd ~/project/terraform/account
                terraform init
                export TF_WORKSPACE=$(~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                terraform apply -lock-timeout=300s --auto-approve

      plan_check_terraform:
        # plan check - with gating check
        executor: terraform
        parameters:
          terraform_level:
            description: choose account / enviroment for level to check
            default: environment
            type: enum
            enum: ["environment", "account"]
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
          approval_step:
            description: approval step to auto approve
            type: string
        steps:
          - checkout
          - run:
              name: Plan Terraform against preproduction and scan for potential issues.
              command: |
                apk update && apk add curl curl-dev bash jq python3 py3-pip --no-cache
                level=<<parameters.terraform_level>>
                echo selecting "${level}" level terraform...
                cd ~/project/terraform/${level}
                echo initialising...
                terraform init
                export WORKSPACE=$(~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV

                echo terraform workspace: $WORKSPACE
                echo running plan against preproduction to check for potential issues.
                terraform workspace select preproduction

                echo plan details:
                terraform plan -lock-timeout=300s -out ${WORKSPACE}.plan  2>&1 | tee  ${WORKSPACE}.log

                echo summary of changes:
                cat ${WORKSPACE}.log | grep '\.' | grep '#' || true

                echo destructive changes:
                set +e
                if [[ "${level}" == "account" ]]
                then
                  cat ${WORKSPACE}.log | grep -E 'destroyed|replaced'
                else
                  cat ${WORKSPACE}.log | grep -E 'aws_security*|aws_ecs_(service|cluster)|aws_s3.*|aws_rds.*|aws_db.*|aws_lb.*' | grep -E 'destroyed|replaced'
                fi
                  if [[ "$?" -eq 0 ]]
                then
                   echo terraform log scan found a possible destructive change.
                   echo please review before approval.
                   exit 1
                else
                    echo terraform log scan found no destructive changes. auto-approval will take place.
                    exit 0
                fi

          - my_slack/notify:
              when: on_fail
              slack_channel: $DEV_SLACK_CHANNEL
              template_file: slack_approval_warning.j2
              replacement_vars: APPROVAL_STEP:=<<parameters.approval_step>> CIRCLE_PULL_REQUEST:=$CIRCLE_PULL_REQUEST CIRCLE_BUILD_URL:=$CIRCLE_BUILD_URL CIRCLE_JOB:=$CIRCLE_JOB
          - run:
              name: auto approve job hold
              when: on_success
              command: |
                ~/project/scripts/pipeline/auto_approve_hold/auto_approve_hold.sh \
                             "${CIRCLE_WORKFLOW_ID}" \
                             "<<parameters.approval_step>>" \
                             "${CIRCLECI_API_KEY}"

      apply_environment_terraform:
        #
        # Apply the environment terraform configuration. This:
        #   - Updates per environment infrastructure; and
        #   - Triggers a deploy of the updated container (if changed)
        #
        executor: terraform
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
        steps:
          - checkout
          - install_workspace_manager
          - run:
              name: Apply Environment Terraform
              command: |
                export IMAGE_TAG=$(~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
                echo $IMAGE_TAG
                cd ~/project/terraform/environment
                terraform init
                export TF_WORKSPACE=$(~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                terraform apply -lock-timeout=300s -auto-approve -parallelism=15 -var container_version=${IMAGE_TAG}
          - run:
              name: register workspace
              command: |
                export TF_WORKSPACE=$(~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                ~/project/terraform-workspace-manager \
                -register-workspace=${TF_WORKSPACE} \
                -time-to-protect=24 \
                -aws-account-id=050256574573 \
                -aws-iam-role=opg-lpa-ci
          - persist_to_workspace:
              root: /tmp
              paths:
                - environment_pipeline_tasks_config.json

      destroy_dev_environment:
        #
        # Destroys a development environment after testing and approval
        # Cannot be run on master branch
        #
        executor: terraform
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
        steps:
          - checkout
          - run:
              name: Destroy Development Environment
              command: |
                export TF_WORKSPACE=$(~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                if [ "${CIRCLE_BRANCH}" != "master" ]; then
                  cd ~/project/terraform/environment
                  terraform init
                  export TF_WORKSPACE=$(~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                  echo $TF_WORKSPACE
                  terraform destroy -lock-timeout=300s -auto-approve
                fi
      seed_environment_databases:
        #
        # Puts data into the database for testing and demo
        #
        executor: python
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
        steps:
          - checkout
          - attach_workspace:
              at: /tmp
          - run:
              name: Install python dependencies
              command: |
                pip install -r scripts/pipeline/requirements.txt --user
          - run:
              name: Wait for new tasks in services to be running
              command: |
                export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                python scripts/pipeline/ecs_monitor/ecs_monitor.py
          - run:
              name: Run seeding ecs task
              command: |
                python scripts/pipeline/start_seeding_task/ecs_start_seeding_task.py

      run_healthcheck_test:
        #
        # Checks the health check is returning 200
        #
        executor: python
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
        steps:
          - checkout
          - attach_workspace:
              at: /tmp
          - run:
              name: Install python dependencies
              command: |
                pip install -r scripts/pipeline/requirements.txt --user
          - install_terraform
          - run:
              name: Wait for new tasks in services to be running
              command: |
                export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                python scripts/pipeline/ecs_monitor/ecs_monitor.py
          - run:
              name: Add CircleCI ingress to environment
              command: |
                if [ <<parameters.workspace>> != "production" ]; then
                  cd ~/project/terraform/account_ingress
                  terraform init
                  export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                  echo $TF_WORKSPACE
                  terraform apply -lock-timeout=300s -auto-approve
                fi
          - run:
              name: Run test
              command: |
                python scripts/pipeline/healthcheck_test/healthcheck_test.py
          - run:
              name: Remove CircleCI ingress to environment
              command: |
                if [ <<parameters.workspace>> != "production" ]; then
                  cd ~/project/terraform/account_ingress
                  terraform init
                  export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                  echo $TF_WORKSPACE
                  terraform destroy -lock-timeout=300s -auto-approve
                fi
              when: always

      run_functional_test:
        #
        # Runs user journey tests using casper JS
        #
        executor: python
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
        steps:
          - checkout
          - setup_remote_docker:
              version: 19.03.12
              docker_layer_caching: false
          - attach_workspace:
              at: /tmp
          - dockerhub_login
          - run:
              name: Build casper JS container
              command: |
                docker build -f ~/project/tests/Dockerfile  -t casperjs:latest .
                echo 'export DOCKER_REMOTE_IP="$(docker run casperjs:latest curl --silent https://checkip.amazonaws.com/)"' >> $BASH_ENV
                echo $DOCKER_REMOTE_IP
          - run:
              name: Install python dependencies
              command: |
                pip install -r scripts/pipeline/requirements.txt --user
          - install_terraform
          - run:
              name: Get URLs
              command: |
                export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                scripts/pipeline/set_environment_variables/set_slack_env_vars.sh >> $BASH_ENV
          - run:
              name: Wait for new tasks in services to be running
              command: |
                export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                python scripts/pipeline/ecs_monitor/ecs_monitor.py
          - run:
              name: Add CircleCI ingress to environment
              command: |
                if [ <<parameters.workspace>> != "production" ]; then
                  cd ~/project/terraform/account_ingress
                  terraform init
                  export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                  echo $TF_WORKSPACE
                  terraform apply -lock-timeout=300s -auto-approve -var docker_remote_ip=$DOCKER_REMOTE_IP
                fi
          - run:
              name: Run casper tests
              command: |
                docker run -dt -e AWS_ACCESS_KEY_ID -e AWS_SECRET_ACCESS_KEY -e AWS_SESSION_TOKEN -e CI -e "BASE_DOMAIN=$PUBLIC_FACING_DOMAIN" --name casperjs casperjs:latest
                docker exec casperjs ./start.sh 'tests/'
          - run:
              name: Remove CircleCI ingress to environment
              command: |
                if [ <<parameters.workspace>> != "production" ]; then
                  cd ~/project/terraform/account_ingress
                  terraform init
                  export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                  echo $TF_WORKSPACE
                  terraform destroy -lock-timeout=300s -auto-approve -var docker_remote_ip=$DOCKER_REMOTE_IP
                fi
              when: always

      run_cypress_test:
        #
        # Runs cypress testing
        #
        executor: python
        parameters:
          workspace:
            description: Terraform workspace name
            type: string
            default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
          cypress_tags:
            description: Cypress tags to be passed in to run of cypress docker container
            type: string
        steps:
          - checkout
          - setup_remote_docker:
              version: 19.03.12
              docker_layer_caching: false
          - attach_workspace:
              at: /tmp
          - dockerhub_login
          - run:
              name: Build cypress container
              command: |
                docker build -f ./cypress/Dockerfile  -t cypress:latest .
                echo 'export DOCKER_CYPRESS_REMOTE_IP="$(docker run -it --entrypoint curl cypress:latest --silent https://checkip.amazonaws.com/ | tr -d '^@')"' >> $BASH_ENV
                echo $DOCKER_CYPRESS_REMOTE_IP
          - run:
              name: Install python dependencies
              command: |
                pip install -r scripts/pipeline/requirements.txt --user
          - install_terraform
          - run:
              name: Get URLs
              command: |
                export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                scripts/pipeline/set_environment_variables/set_slack_env_vars.sh >> $BASH_ENV
          - run:
              name: Wait for new tasks in services to be running
              command: |
                export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                echo $TF_WORKSPACE
                python scripts/pipeline/ecs_monitor/ecs_monitor.py
          - run:
              name: Add CircleCI ingress to environment
              command: |
                if [ <<parameters.workspace>> != "production" ]; then
                  cd ~/project/terraform/account_ingress
                  terraform init
                  export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                  echo $TF_WORKSPACE
                  echo $DOCKER_CYPRESS_REMOTE_IP
                  terraform apply -lock-timeout=300s -auto-approve -var docker_remote_ip=$DOCKER_CYPRESS_REMOTE_IP
                fi
          - run:
              name: Run cypress tests
              command: |
                # if errors occured, we need to restart cypress_tests to copy screenshots from it.  Note, in an ideal world we'd do this using a docker volume, but circle doesn't support that
                docker run -it -e AWS_ACCESS_KEY_ID -e AWS_SECRET_ACCESS_KEY -e AWS_SESSION_TOKEN -e CYPRESS_CI=true -e CYPRESS_TAGS="<<parameters.cypress_tags>>" -e "CYPRESS_baseUrl=https://$PUBLIC_FACING_DOMAIN" -e "CYPRESS_adminUrl=https://$ADMIN_DOMAIN" --entrypoint "./cypress/start.sh" --name cypress_tests cypress:latest && exit 0 || (docker start cypress_tests ; docker cp cypress_tests:/app/cypress/screenshots screenshots ; docker stop cypress_tests ; exit 1)
          - store_artifacts:
              path: screenshots
          - run:
              name: Remove CircleCI ingress to environment
              command: |
                if [ <<parameters.workspace>> != "production" ]; then
                  cd ~/project/terraform/account_ingress
                  terraform init
                  export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
                  echo $TF_WORKSPACE
                  terraform destroy -lock-timeout=300s -auto-approve -var docker_remote_ip=$DOCKER_CYPRESS_REMOTE_IP
                fi
              when: always

jobs:
  cancel_redundant_builds:
    docker:
      - image: circleci/python
        auth:
          username: $DOCKER_USER
          password: $DOCKER_ACCESS_TOKEN
    resource_class: small
    steps:
      - checkout
      - run:
          name: Cancel Redundant Builds
          command: |
            python scripts/pipeline/cancel_previous_jobs/cancel_redundant_builds.py \
            --circle_project_username ${CIRCLE_PROJECT_USERNAME} \
            --circle_project_reponame ${CIRCLE_PROJECT_REPONAME} \
            --circle_branch ${CIRCLE_BRANCH} \
            --circle_builds_token ${CIRCLECI_API_KEY} \
            --terms_to_waitfor "dev_account_apply_terraform,dev_environment_apply_terraform,apply_email_terraform"

  slack_notify_domain:
    docker:
      - image: circleci/python
        auth:
          username: $DOCKER_USER
          password: $DOCKER_ACCESS_TOKEN
    resource_class: small
    parameters:
      workspace:
        description: Terraform workspace name
        type: string
        default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
    steps:
      - checkout
      - attach_workspace:
          at: /tmp
      - run:
          name: Get URLs
          command: |
            export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
            export IMAGE_TAG=$(bash ~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
            echo $TF_WORKSPACE
            echo $IMAGE_TAG
            scripts/pipeline/set_environment_variables/set_slack_env_vars.sh >> $BASH_ENV

      - my_slack/notify:
          when: on_success
          slack_channel: $BUILD_SLACK_CHANNEL
          template_file: post_environment_domains.j2
          replacement_vars: PUBLIC_FACING_DOMAIN:=$PUBLIC_FACING_DOMAIN FRONT_DOMAIN:=$FRONT_DOMAIN ADMIN_DOMAIN:=$ADMIN_DOMAIN CIRCLE_USERNAME:=$CIRCLE_USERNAME CIRCLE_BRANCH:=$CIRCLE_BRANCH CIRCLE_WORKFLOW_ID:=$CIRCLE_WORKFLOW_ID COMMIT_MESSAGE:="$COMMIT_MESSAGE"
      - run:
          name: print deployment values
          command: |
            export IMAGE_TAG=$(bash ~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
            export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
            echo Terraform workspace: $TF_WORKSPACE
            echo Image tag: $IMAGE_TAG
            echo Public Facing Domain: $PUBLIC_FACING_DOMAIN
            echo Front Domain: $FRONT_DOMAIN
            echo Admin Domain: $ADMIN_DOMAIN
  slack_notify_production_release:
    docker:
      - image: circleci/python
        auth:
          username: $DOCKER_USER
          password: $DOCKER_ACCESS_TOKEN
    resource_class: small
    parameters:
      workspace:
        description: Terraform workspace name
        type: string
        default: "${CIRCLE_PULL_REQUEST##*/}-${CIRCLE_BRANCH//[-_]/}"
    steps:
      - checkout
      - attach_workspace:
          at: /tmp
      - run:
          name: Get URLs
          command: |
            export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
            export IMAGE_TAG=$(bash ~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
            echo $TF_WORKSPACE
            echo $IMAGE_TAG
            scripts/pipeline/set_environment_variables/set_slack_env_vars.sh >> $BASH_ENV
            echo PUBLIC_FACING_DOMAIN:=$PUBLIC_FACING_DOMAIN FRONT_DOMAIN:=$FRONT_DOMAIN ADMIN_DOMAIN:=$ADMIN_DOMAIN CIRCLE_USERNAME:=$CIRCLE_USERNAME CIRCLE_BRANCH:=$CIRCLE_BRANCH COMMIT_MESSAGE:="$COMMIT_MESSAGE"
      - my_slack/notify:
          when: on_success
          slack_channel: $LIVE_SLACK_CHANNEL
          template_file: production_release_notification.j2
          replacement_vars: PUBLIC_FACING_DOMAIN:=$PUBLIC_FACING_DOMAIN FRONT_DOMAIN:=$FRONT_DOMAIN ADMIN_DOMAIN:=$ADMIN_DOMAIN CIRCLE_USERNAME:=$CIRCLE_USERNAME CIRCLE_BRANCH:=$CIRCLE_BRANCH COMMIT_MESSAGE:="$COMMIT_MESSAGE"
      - run:
          name: print deployment values
          command: |
            export IMAGE_TAG=$(bash ~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
            export TF_WORKSPACE=$(bash ~/project/scripts/pipeline/set_environment_variables/set_workspace.sh <<parameters.workspace>>) >> $BASH_ENV
            echo Terraform workspace: $TF_WORKSPACE
            echo Image tag: $IMAGE_TAG
            echo Public Facing Domain: $PUBLIC_FACING_DOMAIN
            echo Front Domain: $FRONT_DOMAIN
            echo Admin Domain: $ADMIN_DOMAIN
  ecr_scan_results:
    docker:
      - image: circleci/python
        auth:
          username: $DOCKER_USER
          password: $DOCKER_ACCESS_TOKEN
    resource_class: small
    steps:
      - checkout
      - run:
          name: Check ECR Scan Results
          command: |
            sudo pip3 install -r scripts/pipeline/requirements.txt
            export IMAGE_TAG=$(bash ~/project/scripts/pipeline/set_environment_variables/set_image_tag.sh $CIRCLE_BRANCH $CIRCLE_SHA1) >> $BASH_ENV
                echo $IMAGE_TAG
            python scripts/pipeline/check_ecr_scan_results/aws_ecr_scan_results.py --search online-lpa --tag ${IMAGE_TAG}

  workspace_cleanup:
    docker:
      - image: hashicorp/terraform:1.0.0
        auth:
          username: $DOCKER_USER
          password: $DOCKER_ACCESS_TOKEN
    resource_class: small
    steps:
      - checkout
      - infrastructure_and_deployment/install_workspace_manager
      - run:
          name: Cleanup Workspaces
          command: |
            cd terraform/environment
            terraform init
            export TF_PROTECTED_WORKSPACES=$(~/project/terraform-workspace-manager \
             -protected-workspaces=true \
             -aws-account-id=050256574573 \
             -aws-iam-role=opg-lpa-ci) >> $BASH_ENV
             echo $TF_PROTECTED_WORKSPACES
             ~/project/scripts/pipeline/workspace_cleanup/workspace_cleanup.sh ${TF_PROTECTED_WORKSPACES}
